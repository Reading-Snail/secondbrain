2023-09-25
#클린코드 
*Robert C. Martin*
## 내가 그의 이름을 불러주었을 때
그는 나에게 와서 꽃이 되었다.
결국 애매모호한 표현과 이름을 피해야 된다는 것이다. 단순하지만 모든 것을 품을 수 있는 것들이어야 한다. 글쓰기와 동일하다. 나만 읽을 수 있거나 읽기 복잡하고 어려운 배려없는 글은 훌륭한 글이 아니듯이 코드도 동일하다. 내가 어떻게 불러주는지가 대상을 더 배려심 있고, 사랑스러운 존재로 만든다.
## 함수는 쪼개고, 분리해야 한다
소설과 같은 문학에서는 긴 문장의 글을 선호하기도 한다. 더 깊은 묘사가 가능하기 때문이다. 그러나 나에게 필요한 것은 리포트와 논문과도 같은 명백하고, 읽기 쉬운 글이다. 한 문장이 2줄을 넘어가지 않는 그런 문장 말이다. 
함수(메서드)는 간결하고, 짧아야 된다. 길다면 너무 많은 것을 담고 있는 것일지도 모른다. 떄로는 함수에 클라스에 담겨야할 명사적인 큰 존재를 담으려고해서 넘칠 수도 있다. 함수(메서드)는 동사이다. 동사는 하나의 동작만을 표현한다.
## 주석은 쓰레기다.
주석이 분명 필요할 때도 있다. 그러나 필요악이다. 없앨 수 있다면 여러 방법을 동원해 우회해야 된다. 주석과 코드는 서로 독립된 존재다. 코드 수정후 주석도 수정할 것이라는 생각은 오만이다. 또한 필요해 보이는 주석도 이제는 VCS의 기능들이 처리해준다. 그러므로 주석은 최소화 되어야 된다
## 구조가 잘 짜여진
건물과 같은 구조물은 아름답고, 단순하다. 보기 좋고, 이해하기 편하다는 의미이다.
코드도 그래야한다. 괄호와 띄어쓰기, 메서드의 위치들이 사람의 직관을 관통할 수 있어야 된다.  잘 짜여진 구조의 코드는 스크롤을 줄이고 이해하기 위해 소모되어질 시간을 아껴준다.
- 2 + 2 와 2$*$ 2의 차이를 느낄 것 
## 오류처리와 논리의 분리
예외처리를 통해 논리코드와 오류처리코드를 분리 할 수 있다. 이는 코드를 간결하게 해준다. 뿐만아니라 정확한 예외처리는 프로그램 자체의 안정성까지 책임져준다. 잘쓸 글 = 잘쓴 코드였던 위의 내용과 나란히 하지만 예외처리는 좀더 기술적인 방법들이 중요하게 부각 된다.
아래는 예외처리 방법들이다.
- 오류코드가 아닌 예외처리를 사용한다.
- Try-Catch-Finally문을 먼저 작성하여 구조를 세운다.
- unchecked 예외를 사용한다. (C++, C#에는 checked예외가 없으나 잘 작동한다. 아주 중요한 라이브러리를 작성할 떄만 checked 예외를 사용하도록 한다.)
- 오류를 정의하는 것이 아닌 오류를 잡아내는 것이 목표가 되어야 한다. 죽, 문제재기를 넘어 전후 상황과 해결책을 제시해야 한다.
- Wrapper 클래스를 사용하여 오류를 분류해준다. 
- 특수 사례 패턴: try-catch로 예외를 잡아 작동하는 코드는 상위 비즈니스 코드에서 처리한다.
- 코드를 모호하게 만드는 Null을 반환하기보다는 빈 Collection과 같은 의미 있는 값을 반환하라
- Null은 전달하지 마라. Assert [조건문] : ["메시지"] 문을 사용하여 전달된 Null을 처리한다.
## 외부소스의 내부화
외부소스는 다른 사람과 기관이 만든 코드이다. 그래서 내부에서 사용할 방식에는 딱 들어맞지 않기 마련이다. 그래서 Wrapper로 감싸거나 Adaptor를 사용하여 내부화 해야된다.
- 학습테스트(TDD)를 활용하여 외부 API를 적용할 것을 추천한다. 기록된 테스트들은 다른 외부 API로 변경하거나 사용하던 API가 업데이트 되었을 떄 신속하고 안전하게 반영하도록 해준다.
- Adaptor 패턴을 사용할 경우, 아직 구현되지 않은 API에 맞는 내부코드를 미리 만들  수 있다. 구현되지 않았더라도 외부 API가 전달해줄 값의 의미는 유출 할 수 있다. 이를 근거로 하여 전면에는 Adaptor 인터페이스를 두고 FakeAdaptor를 임시로 구현하여 코드를 짤 수 있다.
## TDD 
한문단으로 요약할 수 없는 또 하나의 개념과 프레임워크 규모의 내용이다.
이 장을 읽고 요약하기 위해 키보드를 두들기기보다는 TDD관련 책을 읽는 것이 맞을 것이다.
## 유연한 클래스는 단순한 클래스이다
단일 책임 원칙(SRP)에 의해서 클래스는 변경해야 할 이유가 단 하나여야 한다. 하나보다 많다면 클래스가 너무 커졌기 때문이다. 하나의 책임만을 갖는 클래스는 단순하기에 변경이 용이해진다. 
또한, 추상 클래스와 인터페이스를 활용하여 의존성 역전 원칙(DIP)을 적용하면 외부의 변화로부터 유연한 코드를 만들 수 있다.





## 시스템
## 창발성

## 신은 디테일 속에 있다. 동시성
컴퓨터는 거짓말 할일이 없지만 거짓말한다고 느껴질 떄가 있다. 바로 동시성이 꺠졌을 떄이다.
동시성 방어 원칙이라 할 수 있는 기본적으로 지켜볼 수 있는 동시성 문제를 해결 할 수 있을 것이다. 그러나 스레드는 매우 섬세하고, 예민하다. 그렇기 떄문에 더 근본적으로 깊게 스레드를 이해하는 방법 밖에 없다. TDD에서도 그랬듯이 **동시성 또한 책 몇권은 읽어야 되는 부분이다.**
#### 동시성 방어 원칙
- SRP - 동시성 코드와 일반 코드를 분리 
- Corollary (따름 정리)
	- 자료를 제한하라: 자료를 캡슐화하고, 공유 자료를 최대한 줄인다.
	- 자료 사본을 사용하라: 자료를 복사해 읽기전용으로 사용 <- 사용된 해결책
	- 스레드는 가능한 독립적으로 구현히리: 쓰레드 간 동기화를 최소화한다.
## 점진적 개선

## JUnit 들여다보기
## 냄새와 휴리스틱
## 동시성2

