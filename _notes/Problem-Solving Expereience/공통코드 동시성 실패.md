2023-10-13

#동시성 #클린코드 
상황:
동시에 접속자들이 조회 또는 등록을 하는 작업을 했을 떄 동시성이 꺠졌다. 일반적인 상황에서는 일어나지 않고, 여러개의 프로시저를 순차적으로 진행하는 작업에서 프로시저들 사이에 타 접속자가 조회해온 데이터가 덮어씌이면서 문제가 발생했다. 프로시저는 소요되는 시간이 초단위로 길다보니 더 쉽게 이러한 결과가 자주 나타난 듯 했다.

분석: 
Service단이 ServiceExecutor를 상속 받아 공통된 정보를 조회하도록 설계 된 구조였다. 여기서 문제점이 Map형식으로 되어있는 공통코드 변수가 전역변수로 선언되어져 있어. 변수에 수정 또는 삭제를 가하는 사건이 타 접속자로부터 발생했을 때 변경된 데이터로 다음 프로시저가 적용되는 문제였다. 우선 이전 프로그램을 마이그레이션 했기 때문에 설계에 있어서 현재 사용하는 프레임워크나 설계에 최적화되어있기 어려웠던 것 같다.

해결책:
우선 적용된 해결책은 전역변수를 직접 사용하는 부분을 제거하고, 지역변수로 데이터를 받아오도록 했다. 그랬더니 우선적으로는 프로시저에 해당하는 동시성 문제는 해결 되었다. 다만 변경해야할 코드가 너무 많기에 일반 조회 코드에 대해서는 수정이 들어가지 않았고, 프로시저 관련 코드에만 수정이 적용 되었다.

추가사항:
그렇다면 정말로 동시성 문제가 사라졌는가에 대해서는 의문이 남았다. 동시 접속자가 그리 많지 않은 프로그램이고, 일반 조회의 경우 소요시간이 매우 짧기 때문에 동시성 문제가 발생항 확률은 현저히 낮아보였다. 그러나 여러 부분에서 문제점이 많은 설계와 코드라고 느껴졌다.

그러다면 어떤 해결책 및 개선사항이 있을 수 있었을까?
최근 읽고 있는 클린코드 - Rober C. Martin :: 동시성 부분에 나온 내용 참고해보자.
**동시성 방어 원칙**
- SRP - 동시성 코드와 일반 코드를 분리 
- Corollary 
	- 자료를 제한하라: 자료를 캡슐화하고, 공유 자료를 최대한 줄인다.
	- 자료 사본을 사용하라: 자료를 복사해 읽기전용으로 사용 <- 사용된 해결책
	- 스레드는 가능한 독립적으로 구현히리: 쓰레드 간 동기화를 최소화한다.
- 라이브러리를 이해하라
	- 자바에서는 다중 스레드에서도 안전한 컬렉션을 제공한다.
	  .e.g ConcurrentHashMap <- 가능성이 있어보여 적용해봤으나 Null값이 있는 경우가 있어 적용이 즉각적인 적용은 어려웠다.
- 실행 모델을 이해하라
	- 생산자-소비자 / 읽기-쓰기 / 식사하는 철학자들 모델과 알고리즘 해법을 이해한다.
- 동기화하는 메서드 사이에는 존재하는 의존성을 이해하라
	- 공유 객체 하나에는 메서드 하나만 사용한다.
	- 메서들 꼭 여러개 사용해야 된다면
**- ............ 이후 내용은 동시성과 관련된 책을 하나 읽어야 된다고 본다.**

우런 위의 방법론적인 접근에서는 '자료사본을 사용하라'를 통해 문제를 해결 할 수 있었다.
추가적으로 ConcurrentHashMap를 적용하는 해결책도 가능성이 있어보여 적용해봤으나 Null값이 있는 경우가 있어 적용이 즉각적인 적용은 어려웠다.

또한 '토비의 스프링 3.1'을 참고한다면 
- 싱글톤으로 접근하여 동시성이 꺠진 것이었기 때문에 Session Scope 방식을 공용데이터 객체에 적용하여 각 접속자별로 독립적으로 데이터를 관리 할 수도 있었을 것 같다. 다만 해당 객체가 ServiceExecutor에서 상속받아서 사용하는 방법이고, POJO 클라스가 아닌 Map으로 구현 되어 있어. 너무나도 큰 공사가 되는 부분이었다.

최근 알게된 ThreadLocal도 해결책이 될 수 있을 것 같다.
- ThreadLocal은 JDK1.2 이후에 추가된 스레드 별로 독립된 변수를 사용할 수 있게 해주는 클래스이다. 이를 활용하면 동시성 문제를 해결 할 수 있을 것으로 짐작된다. 다만 이 또한 코드 전체에 너무나도 많은 수정을 요구하게 되게 때문에 활요하기는 어려워 보였다.

결론: 
임시 방책으로 문제는 해결 했으나, 결국 처음에 얼마나 정교한 설계를 구현해놓았는가가 무었보다 중요하다는 사실을 다시 느끼게 되었다. 사실 STS를 사용하고, Spring 기능을 일부 구현했을지는 모르지만 스프링 프레임워크 철학을 녹여낸 코드와는 매우 거리가 있지 않나 싶었다.


++ 2023-10-20
최종적으로 전역변수로 사용되던 공통변수를 제거하고 기존에 메서드 내에서 사용되던 전역변수는 모두 지역변수로 변경했다. 클린코드에서 나오는 "자료 사본을 사용하라"를 적극적으로 실천한 것이다. 구조적으로 깔끔하고 아름다운 느낌은 아니지만, 공통변수를 사용하지 않는 방법으로 프로시저로 인해 지역현상이 일어날 때 발생하는 동시성을 원천적으로 차단 할 수 있었다.
사실 그렇다 하더라도 지금의 구조가 스레드내에서 순간적으로 발생하는 동시성에 대해서는 안전하지 않을 것 같다는 의문은 남았다. 이는 스프링의 SessionScope가 더 근본적인 해결책 일 것 같다.