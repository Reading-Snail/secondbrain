2023-11-03

상황:
현재 진행중인 프로젝트가 유지보수 단계에서는 GitLab을 기반으로 하여 CI/CD를 적용하여 작동될 예정이라고 한다. 그래서 개발 단계에서는 SVN으로 관리 되던 프로젝트를 Git으로 마이그레이션하고, GitLab과 서버를 연결하여 자동으로 배포가 될 수 있는 환경을 구축해야 했다.

분석: 
CI/CD에 대해서 좀더 깊이 살펴보자!
Continous Intergration/Development이다.
지속적으로 프로젝트를 자동으로 배포하는 개발 방법을 의미한다. 대표적인 프로그램으로는 Jenkinson과 GitLab이 있다. 기본적인 작동방식은 VCS에 변화가 생겼을 때 자동적으로 이를 감지하여 소스를 자동으로 빌드한 후 Shell이니 docker 같은 Executor를 사용하여 서버를 컨트롤하여 배포한다.

브랜치를 통해서 관리 될 때 효용성이 매우 극대화 되는 것으로 보이는데 이는 Branch 개념을 잘 녹여낼 수 있기 때문이다. 브랜치에 개발계, 검증계, 운영계 브랜치를 별도로 만들고, 각각의 브랜치가 업데이트 될 때 해당되는 서버에도 자동으로 배포 되는 방법이다. 이를 활용하여 소스의 변화를 즉각적이고, 편하게 배포하여 단계적으로 테스트 쉽게 개발할 수 있는 환경을 구축 할 수 있다.

해결책 1:
SVN에서 GItLab으로의 마이그레이션은 어렵지 않아 보인다. GitLab도 Git과 GitHub와 같은 전신을 공유하기 때문에 SVN 프로젝트를 Checkout한 후 GitLab으로 Push하면 되는 부분으로 보인다.

문제점 2:
기존에 우선적으로 이클입스 내장 svn과 git을 활용하여 SVN에서 파일을 체크아웃한 후 바로 Git으로 push하는 방법을 사용했었다. 이런 방법의 문제점은 Commit 데이터를 올릴 수 없다는 부분이었다. 또한 불편하다.

해결책 2:
Git에서는 SVN에서 바로 마이그레이션하는 기능을 제공한다. 사용자 계정과 이메일이 중요한 git이기 떄문에 이를 별도의 .txt파일에 맵핑한 후 아래의 코드를 사용하여 마이크레이션 하면 된다.
git svn clone http://svnhost:port/저장소주소 —authors-file=users.txt —no-metadata

Users.txt 파일에서 오류가 있었다. UTF-8 형식이어야 하고, 특정 사용자를 인식하지 못한다면 맨위로 올려보자. 또한 윈도우에서 작성할시 line-ends 설정을 CR-LF(윈도우)에서 LF(Unix)로 변경해야 된다. 운영체제간 인코딩 문제를 뼈에 새기는 시간이었다.
Https://grave32.tistory.com/43

간단하게 소스만 받아온다면 
git svn clone 주소 -r HEAD 를 사용하면 된다

문제점 / 해결책 3:
GitLab Runner를 서버에 설치하고 설정한다.
Docker의 경우 현재 남은 시간상 러닝커브가 너무 높아보인다.

해결
Docker 이미지를 사용하지 않고 서버에 maven을 설치하여 빌드하기로 했다. Maven의 경우 외부망 접속이 불가하여 관련 의존성을 서버에 올렸고 오프라인 모드로 실행하여 war파일을 생성하도록 했다. 개발서버에서 생성한 war를 검증, 운영 서버로 직접 전송 하려고 한다. (각각의 서버에 maven을 설치하는 것이 비효율적이며, 상호 동기화에 문제가 생길 가능성이 높아진다. 가장 좋은 방법은 docker이겠지만 현재로서는 시간이 없다.)
추가적으로 회사 내부 docker 서버를 사용해봤지만 외부망이 안 뚤려있어 maven빌드에 실패했다.
대신 gitlab에서 artifacts를 지원하다는 사실을 알았다 빌드한 파일은 임시 저장하여 CI 과정에서 지속적으로 사용할 수 있었다. Clean 빌드하여 최신 소스코드로 빌드 될 수 있게 한다.

문제 4
Gitlab에서 비교적 최신 버전의 git을 설치하도록 요구한다. gir remote-https 명령어를 사용하기 위해서이다. Git은 rpm파일 조차도 외부 패키지를 불러오므로 사용 할 수 없었다. 

해결4
tar.gz파일을 다운로드 받을 수 잇었고, 이를 C 컴파일링을 하여 설치할 수 있었다. Curl의 최신버전 또한 필요했는데 7.74ver 이상의 경우 보안상 추가적으로 TLS 설정을 요구하여 7.70ver를 선택했다. 

문제점 4:
gitlab-runner에서 초기 git clone을 할 때 git remote-https 명령어를 사용하는데 centos 내장 Curl과 git 버전으로는 사용이 불가했다. 그런데 버전업을 했는데조 자꾸 에러가 발생했다. 

해결책 5:
2시간의 사투 끝에 tar.gz 방식의 설치시 사용되는 C 컴파일 방식에서 .configuration 명령어 사용시 OS에 설치되어있는 프로그램을 기준으로 설치 파일을 만든다는 사실을 알았다 git이 curl에 의존하기 때문에 curl이 완전히 설치된 다음에 git의 컴파일링을 해야 되는 부분이었다. 순서대로 설치하자. 오류가 발생하지 않았다

문제점 6:
파일 복사시 디렉토리가 없어서 에러가 자꾸 발생했다.

해결책 6:
순수 Mkdir의 경우 경로가 이미 있을경우 에러를 발생시킨다. -p 옵션을 사용하여 에러 발생을 막았다.

결과:
최종적으로 개발 검증 운영 배포에 성공했다.
Shell 명령어에 내부적으로 cp 같은 명령어 실행중 에러 발생시 롤백하는 로직이 필요해보인다. 이런부분은 docker 이미지로 구동할 때 상당한 이점이 있는 것으로 아는데 docker 또한 공부를 해야겠다는 동기가 생긴다.

피드백:
사실 cicd보다 리눅스의 여러 설정 및 권한 관리가 매우 어려웠다. 리눅스가 매우 익숙해진 느낌이 늘고 CLI도 더 부담없게 느껴진다.rwx가 눈에 들어오기 시작한다.  777도. 
일주일간 완성하는 꽤나 빡센 일정이었지만 배포의 중요성을 옅보는 좋은 경험이었다. 

클라우드 기반 서비스의 경우 was를 docker이미지로 만들어서 쿠버네티스로 관리한다고 하는데 당연히 사람이 하나하나 할 수 없는 수준의 일이니 자동화가 필수 일 것이다.
나도 그정도의 트래픽과 규모의 프로젝트를 경험하는 날이 오길 바래본다.

++ 추가사항
CI/CD 뿐만아니라 Linux에 더 친해질 수 있는 기회였다. 윈도우가 옆에 있는 이상 리눅스를 본격적으로 접근할 동기를 만들긴 참으로 어렵다. 이번 기회를 통해 많이 친해진 것 같다. 개인 랩탑에서 사용하고 있는 Manjro Linux도 좀더 잘 사용 할 수 있을 듯 하다.
rpm, yum, rm, zip, unizp, tar, root, su -, sudo, cp, cmod 등등 CLI에 명령어와 친해질 수 있어서 즐거웠다.

Docker를 잘 활용 할 수 있었다면 상당부분 쉬워졌을지도 모르겠다. 결국 외부망을 사용 할 수 없기에 제약이 많았을지도 모르겠지만 말이다. Docker도 추후에 꼭 더 깊이 배워보고 싶은 부분이다.
@ 계속 학습하다보니 점점 쉘 및 ci 코드가 익숙해져갔다. 사내 gitlab에서 제공하는 docker 전용 러너가 있음을 발견했고 구동해봤다. 그러나 maven resource plugin 라이브러리를 방호벽으로 인해 외부 링크에서 가져오지 못하여서 동작이 되지는 않았다

이번 CI/CD를 추후 개인 블로그를 배포하는 때도 사용하면 너무 좋을 듯하다. 매번 obsidian으로 관리하고 있는 이 노트가 push 될 때마다 서버상의 나의 블로그의 글이 바로 수정 될 수 있는 환경구축 말이다.

개발자를 돕는 개발자가 되고 싶은 요즘이다. 설계와 환경구축으로 나와 함께 일하는 개발자가 더 몰입하고 집중 할 수 있는 환경을 제공하는 것 말이다. 

CI/CD를 계속해서 유지보수 하던 도중 maven install과 maven package의 차이를 알게 되었다. Maven install의 경우 압축 해제된 상태(?)의 소스까지도 모두 제공하기 떄문에 unzip이나 jar 같은 명령어가 필요하지 않았다. 코드도 maven install롬 변경하고, unzip을 사용하는 stage를 제거하였다. 설치 했던 unzip도 모두 제거 했다.





